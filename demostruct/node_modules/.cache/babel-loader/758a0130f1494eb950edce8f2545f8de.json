{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { isArray, isNil } from '../../../services/predicate';\nimport { isDateValue, dateValuesEqual } from './date_value';\nexport var Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexport var Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Operator.isLTE(clause.operator);\n  }\n});\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nexport var _AST =\n/*#__PURE__*/\nfunction () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    this._clauses = clauses;\n    this._indexedClauses = clauses.reduce(function (map, clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!map.field[clause.field]) {\n            map.field[clause.field] = [];\n          }\n\n          map.field[clause.field].push(clause);\n          return map;\n\n        case Is.TYPE:\n          map.is[clause.flag] = clause;\n          return map;\n\n        case Term.TYPE:\n          map.term.push(clause);\n          return map;\n\n        case Group.TYPE:\n          map.group.push(clause);\n          return map;\n\n        default:\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    }, {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses() {\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return arrayIncludesValue(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return isArray(clause.value) && (isNil(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST([].concat(_toConsumableArray(this._clauses), [newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value) && (isNil(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\nexport var AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});","map":{"version":3,"sources":["/home/ad.rapidops.com/jaymin.shah/project/demostruct/node_modules/@elastic/eui/es/components/search_bar/query/ast.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","arr2","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","isNil","isDateValue","dateValuesEqual","Match","freeze","MUST","MUST_NOT","isMust","match","isMustClause","clause","Operator","EQ","EXACT","GT","GTE","LT","LTE","isEQ","isEQClause","operator","isEXACT","isEXACTClause","isRange","isGT","isGTE","isLT","isLTE","isRangeClause","isGTClause","isGTEClause","isLTClause","isLTEClause","Term","TYPE","isInstance","type","must","mustNot","Group","Field","eq","field","exact","gt","gte","lt","lte","Is","flag","valuesEqual","v1","v2","arrayIncludesValue","array","some","item","_AST","create","clauses","undefined","_clauses","_indexedClauses","reduce","map","is","term","group","Error","concat","getTermClauses","getTermClause","find","getFieldNames","getFieldClauses","getFieldClause","predicate","hasOrFieldClause","getOrFieldClause","addOrFieldValue","existingClause","newClause","removeOrFieldValue","filteredValue","val","removeOrFieldClauses","hasSimpleFieldClause","getSimpleFieldClause","addSimpleFieldValue","addClause","removeSimpleFieldValue","removeSimpleFieldClauses","getIsClauses","values","getIsClause","removeIsClause","getGroupClauses","added","newClauses","get","AST"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { isArray, isNil } from '../../../services/predicate';\nimport { isDateValue, dateValuesEqual } from './date_value';\nexport var Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexport var Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Operator.isLTE(clause.operator);\n  }\n});\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nexport var _AST =\n/*#__PURE__*/\nfunction () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    this._clauses = clauses;\n    this._indexedClauses = clauses.reduce(function (map, clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!map.field[clause.field]) {\n            map.field[clause.field] = [];\n          }\n\n          map.field[clause.field].push(clause);\n          return map;\n\n        case Is.TYPE:\n          map.is[clause.flag] = clause;\n          return map;\n\n        case Term.TYPE:\n          map.term.push(clause);\n          return map;\n\n        case Group.TYPE:\n          map.group.push(clause);\n          return map;\n\n        default:\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    }, {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses() {\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return arrayIncludesValue(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return isArray(clause.value) && (isNil(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST([].concat(_toConsumableArray(this._clauses), [newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value) && (isNil(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\nexport var AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});"]},"metadata":{},"sourceType":"module"}