{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { printIso8601 } from './date_format';\nimport { isDateValue, dateValue } from './date_value';\nimport { AST } from './ast';\nimport { isArray, isDateLike, isString } from '../../../services/predicate';\n\nvar processDateOperation = function processDateOperation(value, operator) {\n  var granularity = value.granularity,\n      resolve = value.resolve;\n  var expression = printIso8601(resolve());\n\n  if (!granularity) {\n    return {\n      operator: operator,\n      expression: expression\n    };\n  }\n\n  switch (operator) {\n    case AST.Operator.GT:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.GTE,\n        expression: expression\n      };\n\n    case AST.Operator.GTE:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LT:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LTE:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.LT,\n        expression: expression\n      };\n\n    default:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        expression: expression\n      };\n  }\n};\n\nexport var _termValuesToQuery = function _termValuesToQuery(values, options) {\n  var body = {\n    query: values.join(' ')\n  };\n\n  if (body.query === '') {\n    return;\n  }\n\n  if (options.defaultFields) {\n    body.fields = options.defaultFields;\n  }\n\n  return {\n    simple_query_string: body\n  };\n};\nexport var _fieldValuesToQuery = function _fieldValuesToQuery(field, operations, andOr) {\n  var queries = [];\n  Object.keys(operations).forEach(function (operator) {\n    var values = operations[operator];\n\n    switch (operator) {\n      case AST.Operator.EQ:\n        var _values$reduce = values.reduce(function (tokenTypes, value) {\n          if (isDateValue(value)) {\n            tokenTypes.dates.push(value);\n          } else if (isDateLike(value)) {\n            tokenTypes.dates.push(dateValue(value));\n          } else if (isString(value) && value.match(/\\s/)) {\n            tokenTypes.phrases.push(value);\n          } else {\n            tokenTypes.terms.push(value);\n          }\n\n          return tokenTypes;\n        }, {\n          terms: [],\n          phrases: [],\n          dates: []\n        }),\n            terms = _values$reduce.terms,\n            phrases = _values$reduce.phrases,\n            dates = _values$reduce.dates;\n\n        if (terms.length > 0) {\n          queries.push({\n            match: _defineProperty({}, field, {\n              query: terms.join(' '),\n              operator: andOr\n            })\n          });\n        }\n\n        if (phrases.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(phrases.map(function (phrase) {\n            return {\n              match_phrase: _defineProperty({}, field, phrase)\n            };\n          })));\n        }\n\n        if (dates.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(dates.map(function (value) {\n            return {\n              match: _defineProperty({}, field, processDateOperation(value).expression)\n            };\n          })));\n        }\n\n        break;\n\n      default:\n        values.forEach(function (value) {\n          if (isDateValue(value)) {\n            var operation = processDateOperation(value, operator);\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operation.operator, operation.expression))\n            });\n          } else {\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operator, value))\n            });\n          }\n        });\n    }\n  });\n\n  if (queries.length === 1) {\n    return queries[0];\n  }\n\n  var key = andOr === 'and' ? 'must' : 'should';\n  return {\n    bool: _defineProperty({}, key, [].concat(queries))\n  };\n};\nexport var _isFlagToQuery = function _isFlagToQuery(flag, on) {\n  return {\n    term: _defineProperty({}, flag, on)\n  };\n};\n\nvar collectTerms = function collectTerms(clauses) {\n  return clauses.reduce(function (values, clause) {\n    if (AST.Match.isMustClause(clause)) {\n      values.must.push(clause.value);\n    } else {\n      values.mustNot.push(clause.value);\n    }\n\n    return values;\n  }, {\n    must: [],\n    mustNot: []\n  });\n};\n\nvar collectFields = function collectFields(clauses) {\n  var fieldArray = function fieldArray(obj, field, operator) {\n    if (!obj[field]) {\n      obj[field] = {};\n    }\n\n    if (!obj[field][operator]) {\n      obj[field][operator] = [];\n    }\n\n    return obj[field][operator];\n  };\n\n  return clauses.reduce(function (fields, clause) {\n    if (AST.Match.isMustClause(clause)) {\n      if (isArray(clause.value)) {\n        var _fieldArray;\n\n        (_fieldArray = fieldArray(fields.must.or, clause.field, clause.operator)).push.apply(_fieldArray, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.must.and, clause.field, clause.operator).push(clause.value);\n      }\n    } else {\n      if (isArray(clause.value)) {\n        var _fieldArray2;\n\n        (_fieldArray2 = fieldArray(fields.mustNot.or, clause.field, clause.operator)).push.apply(_fieldArray2, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.mustNot.and, clause.field, clause.operator).push(clause.value);\n      }\n    }\n\n    return fields;\n  }, {\n    must: {\n      and: {},\n      or: {}\n    },\n    mustNot: {\n      and: {},\n      or: {}\n    }\n  });\n};\n\nvar clausesToEsQueryDsl = function clausesToEsQueryDsl(_ref) {\n  var fields = _ref.fields,\n      terms = _ref.terms,\n      is = _ref.is;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var extraMustQueries = options.extraMustQueries || [];\n  var extraMustNotQueries = options.extraMustNotQueries || [];\n  var termValuesToQuery = options.termValuesToQuery || _termValuesToQuery;\n  var fieldValuesToQuery = options.fieldValuesToQuery || _fieldValuesToQuery;\n  var isFlagToQuery = options.isFlagToQuery || _isFlagToQuery;\n  var must = [];\n  must.push.apply(must, _toConsumableArray(extraMustQueries));\n  var termMustQuery = termValuesToQuery(terms.must, options);\n\n  if (termMustQuery) {\n    must.push(termMustQuery);\n  }\n\n  Object.keys(fields.must.and).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.and[field], 'and'));\n  });\n  Object.keys(fields.must.or).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.or[field], 'or'));\n  });\n  is.forEach(function (clause) {\n    must.push(isFlagToQuery(clause.flag, AST.Match.isMustClause(clause)));\n  });\n  var mustNot = [];\n  mustNot.push.apply(mustNot, _toConsumableArray(extraMustNotQueries));\n  var termMustNotQuery = termValuesToQuery(terms.mustNot, options);\n\n  if (termMustNotQuery) {\n    mustNot.push(termMustNotQuery);\n  }\n\n  Object.keys(fields.mustNot.and).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.and[field], 'and'));\n  });\n  Object.keys(fields.mustNot.or).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.or[field], 'or'));\n  });\n  var bool = {};\n\n  if (must.length !== 0) {\n    bool.must = must;\n  }\n\n  if (mustNot.length !== 0) {\n    bool.must_not = mustNot;\n  }\n\n  return bool;\n};\n\nvar EMPTY_TERMS = {\n  must: [],\n  mustNot: []\n};\nvar EMPTY_FIELDS = {\n  must: {\n    and: {},\n    or: {}\n  },\n  mustNot: {\n    and: {},\n    or: {}\n  }\n};\nexport var astToEsQueryDsl = function astToEsQueryDsl(ast, options) {\n  if (ast.clauses.length === 0) {\n    return {\n      match_all: {}\n    };\n  }\n\n  var terms = collectTerms(ast.getTermClauses());\n  var fields = collectFields(ast.getFieldClauses());\n  var is = ast.getIsClauses();\n  var matchesBool = clausesToEsQueryDsl({\n    terms: terms,\n    fields: fields,\n    is: is\n  }, options);\n  var hasTopMatches = Object.keys(matchesBool).length > 0;\n  var groupClauses = ast.getGroupClauses();\n\n  if (groupClauses.length === 0) {\n    // there are no GroupClauses, everything at top level is combined as a must\n    return {\n      bool: matchesBool\n    };\n  } else {\n    // there is at least one GroupClause, wrap the above clauses in another layer and append the ORs\n    var must = groupClauses.reduce(function (must, groupClause) {\n      var clauses = groupClause.value.reduce(function (clauses, clause) {\n        if (AST.Term.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: collectTerms([clause]),\n            fields: EMPTY_FIELDS,\n            is: []\n          }));\n        } else if (AST.Field.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: collectFields([clause]),\n            is: []\n          }));\n        } else if (AST.Is.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: EMPTY_FIELDS,\n            is: [clause]\n          }));\n        }\n\n        return clauses;\n      }, []);\n      must.push({\n        bool: {\n          should: clauses.map(function (clause) {\n            return {\n              bool: clause\n            };\n          })\n        }\n      });\n      return must;\n    }, hasTopMatches // only include the first match group if there are any conditions\n    ? [{\n      bool: matchesBool\n    }] : []);\n    return {\n      bool: {\n        must: must\n      }\n    };\n  }\n};","map":{"version":3,"sources":["/home/ad.rapidops.com/jaymin.shah/project/demostruct/node_modules/@elastic/eui/es/components/search_bar/query/ast_to_es_query_dsl.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","printIso8601","isDateValue","dateValue","AST","isDateLike","isString","processDateOperation","operator","granularity","resolve","expression","Operator","GT","concat","es","GTE","LT","LTE","_termValuesToQuery","values","options","body","query","join","defaultFields","fields","simple_query_string","_fieldValuesToQuery","field","operations","andOr","queries","keys","forEach","EQ","_values$reduce","reduce","tokenTypes","dates","push","match","phrases","terms","apply","map","phrase","match_phrase","operation","range","bool","_isFlagToQuery","flag","on","term","collectTerms","clauses","clause","Match","isMustClause","must","mustNot","collectFields","fieldArray","_fieldArray","or","and","_fieldArray2","clausesToEsQueryDsl","_ref","is","arguments","undefined","extraMustQueries","extraMustNotQueries","termValuesToQuery","fieldValuesToQuery","isFlagToQuery","termMustQuery","termMustNotQuery","must_not","EMPTY_TERMS","EMPTY_FIELDS","astToEsQueryDsl","ast","match_all","getTermClauses","getFieldClauses","getIsClauses","matchesBool","hasTopMatches","groupClauses","getGroupClauses","groupClause","Term","isInstance","Field","Is","should"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { printIso8601 } from './date_format';\nimport { isDateValue, dateValue } from './date_value';\nimport { AST } from './ast';\nimport { isArray, isDateLike, isString } from '../../../services/predicate';\n\nvar processDateOperation = function processDateOperation(value, operator) {\n  var granularity = value.granularity,\n      resolve = value.resolve;\n  var expression = printIso8601(resolve());\n\n  if (!granularity) {\n    return {\n      operator: operator,\n      expression: expression\n    };\n  }\n\n  switch (operator) {\n    case AST.Operator.GT:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.GTE,\n        expression: expression\n      };\n\n    case AST.Operator.GTE:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LT:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        operator: operator,\n        expression: expression\n      };\n\n    case AST.Operator.LTE:\n      expression = \"\".concat(expression, \"||+1\").concat(granularity.es, \"/\").concat(granularity.es);\n      return {\n        operator: AST.Operator.LT,\n        expression: expression\n      };\n\n    default:\n      expression = \"\".concat(expression, \"||/\").concat(granularity.es);\n      return {\n        expression: expression\n      };\n  }\n};\n\nexport var _termValuesToQuery = function _termValuesToQuery(values, options) {\n  var body = {\n    query: values.join(' ')\n  };\n\n  if (body.query === '') {\n    return;\n  }\n\n  if (options.defaultFields) {\n    body.fields = options.defaultFields;\n  }\n\n  return {\n    simple_query_string: body\n  };\n};\nexport var _fieldValuesToQuery = function _fieldValuesToQuery(field, operations, andOr) {\n  var queries = [];\n  Object.keys(operations).forEach(function (operator) {\n    var values = operations[operator];\n\n    switch (operator) {\n      case AST.Operator.EQ:\n        var _values$reduce = values.reduce(function (tokenTypes, value) {\n          if (isDateValue(value)) {\n            tokenTypes.dates.push(value);\n          } else if (isDateLike(value)) {\n            tokenTypes.dates.push(dateValue(value));\n          } else if (isString(value) && value.match(/\\s/)) {\n            tokenTypes.phrases.push(value);\n          } else {\n            tokenTypes.terms.push(value);\n          }\n\n          return tokenTypes;\n        }, {\n          terms: [],\n          phrases: [],\n          dates: []\n        }),\n            terms = _values$reduce.terms,\n            phrases = _values$reduce.phrases,\n            dates = _values$reduce.dates;\n\n        if (terms.length > 0) {\n          queries.push({\n            match: _defineProperty({}, field, {\n              query: terms.join(' '),\n              operator: andOr\n            })\n          });\n        }\n\n        if (phrases.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(phrases.map(function (phrase) {\n            return {\n              match_phrase: _defineProperty({}, field, phrase)\n            };\n          })));\n        }\n\n        if (dates.length > 0) {\n          queries.push.apply(queries, _toConsumableArray(dates.map(function (value) {\n            return {\n              match: _defineProperty({}, field, processDateOperation(value).expression)\n            };\n          })));\n        }\n\n        break;\n\n      default:\n        values.forEach(function (value) {\n          if (isDateValue(value)) {\n            var operation = processDateOperation(value, operator);\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operation.operator, operation.expression))\n            });\n          } else {\n            queries.push({\n              range: _defineProperty({}, field, _defineProperty({}, operator, value))\n            });\n          }\n        });\n    }\n  });\n\n  if (queries.length === 1) {\n    return queries[0];\n  }\n\n  var key = andOr === 'and' ? 'must' : 'should';\n  return {\n    bool: _defineProperty({}, key, [].concat(queries))\n  };\n};\nexport var _isFlagToQuery = function _isFlagToQuery(flag, on) {\n  return {\n    term: _defineProperty({}, flag, on)\n  };\n};\n\nvar collectTerms = function collectTerms(clauses) {\n  return clauses.reduce(function (values, clause) {\n    if (AST.Match.isMustClause(clause)) {\n      values.must.push(clause.value);\n    } else {\n      values.mustNot.push(clause.value);\n    }\n\n    return values;\n  }, {\n    must: [],\n    mustNot: []\n  });\n};\n\nvar collectFields = function collectFields(clauses) {\n  var fieldArray = function fieldArray(obj, field, operator) {\n    if (!obj[field]) {\n      obj[field] = {};\n    }\n\n    if (!obj[field][operator]) {\n      obj[field][operator] = [];\n    }\n\n    return obj[field][operator];\n  };\n\n  return clauses.reduce(function (fields, clause) {\n    if (AST.Match.isMustClause(clause)) {\n      if (isArray(clause.value)) {\n        var _fieldArray;\n\n        (_fieldArray = fieldArray(fields.must.or, clause.field, clause.operator)).push.apply(_fieldArray, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.must.and, clause.field, clause.operator).push(clause.value);\n      }\n    } else {\n      if (isArray(clause.value)) {\n        var _fieldArray2;\n\n        (_fieldArray2 = fieldArray(fields.mustNot.or, clause.field, clause.operator)).push.apply(_fieldArray2, _toConsumableArray(clause.value));\n      } else {\n        fieldArray(fields.mustNot.and, clause.field, clause.operator).push(clause.value);\n      }\n    }\n\n    return fields;\n  }, {\n    must: {\n      and: {},\n      or: {}\n    },\n    mustNot: {\n      and: {},\n      or: {}\n    }\n  });\n};\n\nvar clausesToEsQueryDsl = function clausesToEsQueryDsl(_ref) {\n  var fields = _ref.fields,\n      terms = _ref.terms,\n      is = _ref.is;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var extraMustQueries = options.extraMustQueries || [];\n  var extraMustNotQueries = options.extraMustNotQueries || [];\n  var termValuesToQuery = options.termValuesToQuery || _termValuesToQuery;\n  var fieldValuesToQuery = options.fieldValuesToQuery || _fieldValuesToQuery;\n  var isFlagToQuery = options.isFlagToQuery || _isFlagToQuery;\n  var must = [];\n  must.push.apply(must, _toConsumableArray(extraMustQueries));\n  var termMustQuery = termValuesToQuery(terms.must, options);\n\n  if (termMustQuery) {\n    must.push(termMustQuery);\n  }\n\n  Object.keys(fields.must.and).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.and[field], 'and'));\n  });\n  Object.keys(fields.must.or).forEach(function (field) {\n    must.push(fieldValuesToQuery(field, fields.must.or[field], 'or'));\n  });\n  is.forEach(function (clause) {\n    must.push(isFlagToQuery(clause.flag, AST.Match.isMustClause(clause)));\n  });\n  var mustNot = [];\n  mustNot.push.apply(mustNot, _toConsumableArray(extraMustNotQueries));\n  var termMustNotQuery = termValuesToQuery(terms.mustNot, options);\n\n  if (termMustNotQuery) {\n    mustNot.push(termMustNotQuery);\n  }\n\n  Object.keys(fields.mustNot.and).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.and[field], 'and'));\n  });\n  Object.keys(fields.mustNot.or).forEach(function (field) {\n    mustNot.push(fieldValuesToQuery(field, fields.mustNot.or[field], 'or'));\n  });\n  var bool = {};\n\n  if (must.length !== 0) {\n    bool.must = must;\n  }\n\n  if (mustNot.length !== 0) {\n    bool.must_not = mustNot;\n  }\n\n  return bool;\n};\n\nvar EMPTY_TERMS = {\n  must: [],\n  mustNot: []\n};\nvar EMPTY_FIELDS = {\n  must: {\n    and: {},\n    or: {}\n  },\n  mustNot: {\n    and: {},\n    or: {}\n  }\n};\nexport var astToEsQueryDsl = function astToEsQueryDsl(ast, options) {\n  if (ast.clauses.length === 0) {\n    return {\n      match_all: {}\n    };\n  }\n\n  var terms = collectTerms(ast.getTermClauses());\n  var fields = collectFields(ast.getFieldClauses());\n  var is = ast.getIsClauses();\n  var matchesBool = clausesToEsQueryDsl({\n    terms: terms,\n    fields: fields,\n    is: is\n  }, options);\n  var hasTopMatches = Object.keys(matchesBool).length > 0;\n  var groupClauses = ast.getGroupClauses();\n\n  if (groupClauses.length === 0) {\n    // there are no GroupClauses, everything at top level is combined as a must\n    return {\n      bool: matchesBool\n    };\n  } else {\n    // there is at least one GroupClause, wrap the above clauses in another layer and append the ORs\n    var must = groupClauses.reduce(function (must, groupClause) {\n      var clauses = groupClause.value.reduce(function (clauses, clause) {\n        if (AST.Term.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: collectTerms([clause]),\n            fields: EMPTY_FIELDS,\n            is: []\n          }));\n        } else if (AST.Field.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: collectFields([clause]),\n            is: []\n          }));\n        } else if (AST.Is.isInstance(clause)) {\n          clauses.push(clausesToEsQueryDsl({\n            terms: EMPTY_TERMS,\n            fields: EMPTY_FIELDS,\n            is: [clause]\n          }));\n        }\n\n        return clauses;\n      }, []);\n      must.push({\n        bool: {\n          should: clauses.map(function (clause) {\n            return {\n              bool: clause\n            };\n          })\n        }\n      });\n      return must;\n    }, hasTopMatches // only include the first match group if there are any conditions\n    ? [{\n      bool: matchesBool\n    }] : []);\n    return {\n      bool: {\n        must: must\n      }\n    };\n  }\n};"]},"metadata":{},"sourceType":"module"}