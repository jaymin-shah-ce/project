{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { defaultSyntax } from './default_syntax';\nimport { executeAst } from './execute_ast';\nimport { isNil, isString } from '../../../services/predicate';\nimport { astToEsQueryDsl } from './ast_to_es_query_dsl';\nimport { astToEsQueryString } from './ast_to_es_query_string';\nimport { dateValueParser } from './date_value';\nimport { AST, Operator } from './ast';\n/**\n * This is the consumer interface for the query - it's effectively a wrapper construct around\n * the AST and some of its related utility functions (e.g. parsing, text representation, executing, etc...)\n * It is immutable - all mutating operations return a new (mutated) query instance.\n */\n\nexport var Query =\n/*#__PURE__*/\nfunction () {\n  _createClass(Query, null, [{\n    key: \"parse\",\n    value: function parse(text, options) {\n      var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSyntax;\n      return new Query(syntax.parse(text, options), syntax, text);\n    }\n  }, {\n    key: \"parseDateValue\",\n    value: function parseDateValue(value) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return dateValueParser(format)(value);\n    }\n  }, {\n    key: \"isMust\",\n    value: function isMust(clause) {\n      return AST.Match.isMustClause(clause);\n    }\n  }, {\n    key: \"isTerm\",\n    value: function isTerm(clause) {\n      return AST.Term.isInstance(clause);\n    }\n  }, {\n    key: \"isIs\",\n    value: function isIs(clause) {\n      return AST.Is.isInstance(clause);\n    }\n  }, {\n    key: \"isField\",\n    value: function isField(clause) {\n      return AST.Field.isInstance(clause);\n    }\n  }]);\n\n  function Query(ast) {\n    var syntax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSyntax;\n    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n    _classCallCheck(this, Query);\n\n    this.ast = ast;\n    this.text = text || syntax.print(ast);\n    this.syntax = syntax;\n  }\n\n  _createClass(Query, [{\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.ast.hasSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.ast.getSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var ast = this.ast.removeSimpleFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var ast = this.ast.addSimpleFieldValue(field, value, must, operator);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var ast = this.ast.removeSimpleFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.ast.hasOrFieldClause(field, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.ast.getOrFieldClause(field, value);\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var ast = this.ast.addOrFieldValue(field, value, must);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var ast = this.ast.removeOrFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var ast = this.ast.removeOrFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasIsClause\",\n    value: function hasIsClause(flag) {\n      return !isNil(this.ast.getIsClause(flag));\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this.ast.getIsClause(flag);\n    }\n  }, {\n    key: \"addMustIsClause\",\n    value: function addMustIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.must(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addMustNotIsClause\",\n    value: function addMustNotIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.mustNot(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      var ast = this.ast.removeIsClause(flag);\n      return new Query(ast, this.syntax);\n    }\n    /**\n     * Executes this query over the given iterable item and returns\n     * an new array of all items that matched this query. Options:\n     *\n     * defaultFields: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isClauseMatcher?: (record: any, flag: string, applied: boolean, explain?: []) => boolean\n     *\n     *    By default the 'is' clauses will try to match against boolean fields - where the flag of the clause\n     *    indicates the field name. You can change this behaviour by providing this matcher function for the\n     *    is clause. For example, if the object has a `tags` field, one can create a matcher that checks if\n     *    an object has a specific tag (e.g. \"is:marketing\", \"is:kitchen\", etc..)\n     *\n     * explain?: boolean\n     *\n     *    When set to `true`, each item in the returns array will have an `__explain` field that will hold\n     *    information about why the objects matched the query (default to `false`, mainly/only useful for\n     *    debugging)\n     */\n\n  }], [{\n    key: \"execute\",\n    value: function execute(query, items) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return executeAst(q.ast, items, options);\n    }\n    /**\n     * Builds and returns an Elasticsearch query out this query. Options:\n     *\n     * defaultFields?: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isToQuery?: (flag: string, on: boolean) => Object (elasticsearch query object)\n     *\n     *    By default, \"is\" clauses will be translated to a term query where the flag is the field\n     *    and the \"on\" value will be the value of the field. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * termValuesToQuery?: (values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"term\" clauses will be translated to a \"simple_query_string\" query where all\n     *    the values serve as terms in the query string. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * fieldValuesToAndQuery?: (field: string, values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"field\" clauses will be translated to a match query where all the values serve as\n     *    terms in the query(the operator is AND). This function lets you change this default translation\n     *    and provide your own custom one.\n     */\n\n  }, {\n    key: \"toESQuery\",\n    value: function toESQuery(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryDsl(q.ast, options);\n    }\n  }, {\n    key: \"toESQueryString\",\n    value: function toESQueryString(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryString(q.ast, options);\n    }\n  }]);\n\n  return Query;\n}();\n\n_defineProperty(Query, \"MATCH_ALL\", Query.parse(''));","map":{"version":3,"sources":["/home/ad.rapidops.com/jaymin.shah/project/demostruct/node_modules/@elastic/eui/es/components/search_bar/query/query.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","defaultSyntax","executeAst","isNil","isString","astToEsQueryDsl","astToEsQueryString","dateValueParser","AST","Operator","Query","parse","text","options","syntax","arguments","undefined","parseDateValue","format","isMust","clause","Match","isMustClause","isTerm","Term","isInstance","isIs","Is","isField","Field","ast","print","hasSimpleFieldClause","field","getSimpleFieldClause","removeSimpleFieldClauses","addSimpleFieldValue","must","operator","EQ","removeSimpleFieldValue","hasOrFieldClause","getOrFieldClause","addOrFieldValue","removeOrFieldValue","removeOrFieldClauses","hasIsClause","flag","getIsClause","addMustIsClause","addClause","addMustNotIsClause","mustNot","removeIsClause","execute","query","items","q","toESQuery","toESQueryString"],"mappings":"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","sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defaultSyntax } from './default_syntax';\nimport { executeAst } from './execute_ast';\nimport { isNil, isString } from '../../../services/predicate';\nimport { astToEsQueryDsl } from './ast_to_es_query_dsl';\nimport { astToEsQueryString } from './ast_to_es_query_string';\nimport { dateValueParser } from './date_value';\nimport { AST, Operator } from './ast';\n/**\n * This is the consumer interface for the query - it's effectively a wrapper construct around\n * the AST and some of its related utility functions (e.g. parsing, text representation, executing, etc...)\n * It is immutable - all mutating operations return a new (mutated) query instance.\n */\n\nexport var Query =\n/*#__PURE__*/\nfunction () {\n  _createClass(Query, null, [{\n    key: \"parse\",\n    value: function parse(text, options) {\n      var syntax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSyntax;\n      return new Query(syntax.parse(text, options), syntax, text);\n    }\n  }, {\n    key: \"parseDateValue\",\n    value: function parseDateValue(value) {\n      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return dateValueParser(format)(value);\n    }\n  }, {\n    key: \"isMust\",\n    value: function isMust(clause) {\n      return AST.Match.isMustClause(clause);\n    }\n  }, {\n    key: \"isTerm\",\n    value: function isTerm(clause) {\n      return AST.Term.isInstance(clause);\n    }\n  }, {\n    key: \"isIs\",\n    value: function isIs(clause) {\n      return AST.Is.isInstance(clause);\n    }\n  }, {\n    key: \"isField\",\n    value: function isField(clause) {\n      return AST.Field.isInstance(clause);\n    }\n  }]);\n\n  function Query(ast) {\n    var syntax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSyntax;\n    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n    _classCallCheck(this, Query);\n\n    this.ast = ast;\n    this.text = text || syntax.print(ast);\n    this.syntax = syntax;\n  }\n\n  _createClass(Query, [{\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.ast.hasSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field, value) {\n      return this.ast.getSimpleFieldClause(field, value);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var ast = this.ast.removeSimpleFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var ast = this.ast.addSimpleFieldValue(field, value, must, operator);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var ast = this.ast.removeSimpleFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.ast.hasOrFieldClause(field, value);\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field, value) {\n      return this.ast.getOrFieldClause(field, value);\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var ast = this.ast.addOrFieldValue(field, value, must);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var ast = this.ast.removeOrFieldValue(field, value);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var ast = this.ast.removeOrFieldClauses(field);\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"hasIsClause\",\n    value: function hasIsClause(flag) {\n      return !isNil(this.ast.getIsClause(flag));\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this.ast.getIsClause(flag);\n    }\n  }, {\n    key: \"addMustIsClause\",\n    value: function addMustIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.must(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"addMustNotIsClause\",\n    value: function addMustNotIsClause(flag) {\n      var ast = this.ast.addClause(AST.Is.mustNot(flag));\n      return new Query(ast, this.syntax);\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      var ast = this.ast.removeIsClause(flag);\n      return new Query(ast, this.syntax);\n    }\n    /**\n     * Executes this query over the given iterable item and returns\n     * an new array of all items that matched this query. Options:\n     *\n     * defaultFields: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isClauseMatcher?: (record: any, flag: string, applied: boolean, explain?: []) => boolean\n     *\n     *    By default the 'is' clauses will try to match against boolean fields - where the flag of the clause\n     *    indicates the field name. You can change this behaviour by providing this matcher function for the\n     *    is clause. For example, if the object has a `tags` field, one can create a matcher that checks if\n     *    an object has a specific tag (e.g. \"is:marketing\", \"is:kitchen\", etc..)\n     *\n     * explain?: boolean\n     *\n     *    When set to `true`, each item in the returns array will have an `__explain` field that will hold\n     *    information about why the objects matched the query (default to `false`, mainly/only useful for\n     *    debugging)\n     */\n\n  }], [{\n    key: \"execute\",\n    value: function execute(query, items) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return executeAst(q.ast, items, options);\n    }\n    /**\n     * Builds and returns an Elasticsearch query out this query. Options:\n     *\n     * defaultFields?: string[]\n     *\n     *    An array of field names to match the default clauses against. When not specified, the query\n     *    will pick up all the string fields of each record and try to match against those.\n     *\n     * isToQuery?: (flag: string, on: boolean) => Object (elasticsearch query object)\n     *\n     *    By default, \"is\" clauses will be translated to a term query where the flag is the field\n     *    and the \"on\" value will be the value of the field. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * termValuesToQuery?: (values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"term\" clauses will be translated to a \"simple_query_string\" query where all\n     *    the values serve as terms in the query string. This function lets you change this default\n     *    translation and provide your own custom one.\n     *\n     * fieldValuesToAndQuery?: (field: string, values: string[]) => Object (elasticsearch query object)\n     *\n     *    By default, \"field\" clauses will be translated to a match query where all the values serve as\n     *    terms in the query(the operator is AND). This function lets you change this default translation\n     *    and provide your own custom one.\n     */\n\n  }, {\n    key: \"toESQuery\",\n    value: function toESQuery(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryDsl(q.ast, options);\n    }\n  }, {\n    key: \"toESQueryString\",\n    value: function toESQueryString(query) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var q = isString(query) ? Query.parse(query) : query;\n      return astToEsQueryString(q.ast, options);\n    }\n  }]);\n\n  return Query;\n}();\n\n_defineProperty(Query, \"MATCH_ALL\", Query.parse(''));"]},"metadata":{},"sourceType":"module"}